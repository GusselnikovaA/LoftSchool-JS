// срабоатет, когда браузер установит serviceWorker, нужен для того чтобы закэшировать что мы хотим. 
// в данном случае кэшируем данные (просим добавить эти файлы в кэш, чтобы доставать их оттуда, когда не будет интернета)
addEventListener('install', event => {
    // в объекте нашего события event есть метод waitUntil, который ждет пока весь promise внутри не разрешится
    event.waitUntil(
        // Инициализируем кэш caches.open (возвращает promise). 
        // глобальный объект caches всегда доступен в SW. 
        // В данном случае называем наше хранилище offline, может быть названо как угодно
        caches.open('offline')
            .then(cache => {
                // вносим информацию что хотим закэшировать через метод addAll. 
                return cache.addAll([
                    '/',
                    '/serviceWorker.html',
                    '/bootstrap.min/css'
                ]);
            })
    );
});
// если ресурс за которым отправляет страница существует в кэше, то отдать его из кэша
// Будем перехватывает все запросы со страницы
// чтобы перехватывать запросы достаточно повесить обработчик события на fetch. 
// Задача события fetch сказать браузеру каким должен быть ответ на текущий запрос. Для каждого запроса генерируется событие fetch
addEventListener('fetch', event => {
    // метод respondWith принимает promise.
    // с каким ответом этот promise разрешится, так прос и ответит
    event.respondWith( new Promise(async (resolve, reject) => {
        // event.request содержит информацию о нашем текущем запросе, куда  и за каким ресурсом отправляем запрос
        const request = event.request;
    
        try {
            // инициализируем хранилище с кэшом
            const storage = await caches.open('offline');
            // чтобы получить ранее закэшированный ответ, надо вызвать у кэша метод match
            // т.е. мы спрашиваем у хранилища, кэшировал ли он ранее ответ на такой запрос(передается в request)
            // если информации нет то cachуe = undefined
            const cache = await storage.match(request);

            // проверяем есть ли что-то в cache
            // если есть, то разрешаем наш promise ответом из кэша
            if (cache) {
                resolve(cache);
            // если нет, то отправляем этот запрос, получаем ответ от сервера и разрешаем promice текущим ответом
            } else {
                const response = await fetch(request);
                resolve(response);
            }
        // если в блоке try произошла ошибка, то в promise возвращается reject
        } catch (e) {
            reject(e);
        }
    }));
});